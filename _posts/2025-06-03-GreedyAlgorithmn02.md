---
Title: GreedyAlgorithm02
Date: 2025-6-3
---
# 算法训练营 | 122.买卖股票的最佳时机 II | 55. 跳跃游戏 | 45.跳跃游戏 II | 1005.K次取反后最大化的数组和
## 122.买卖股票的最佳时机 II
给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。\
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）\
示例 1:\
输入: [7,1,5,3,6,4]\
输出: 7\
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
### 关键词
贪心算法
### 难点
本题的列表是有着自己固定的顺序的，因此不能采用一般的排序方法解决解决贪心问题的思路。\
本题最重要的信息就是买入和卖出，实际上这几天的交易所获得的利润可以分割成多此交易获得的利润总和。这就能分割成子问题。\
同时，只持有一支股票，也就是同时只能做一次交易，杜绝了子问题重叠的情况（多只股票同时交易），而解决无重复子问题的方法就是贪心算法。\
数组中相邻两个元素，后一个元素减去前一个元素就是这两天交易获取到的利润。同理同一天买卖获得的利润为0（同一个价格买入卖出）。\
思路就有了，通过计算相邻两个数的差，得到这两天求得的利润，若为正，说明第一天买，第二天买是有利可得的，为了赚取更多的钱，虽然有利可得但是仍不卖出，等待下一个交易日。\
接着在移动到下一个二元组，也就是下一个交易日，如果仍是正数则说明仍有利可得，下一个交易日再卖出能赚更多钱；如果为负数，则说明在这个交易日会亏钱，立马在上一个交易日卖出，开启新一轮的买卖。\
### 代码
~~~C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
~~~
### 总结
贪心算法的核心就是非重叠的子问题
## 55. 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。\
数组中的每个元素代表你在该位置可以跳跃的最大长度。\
判断你是否能够到达最后一个位置。\
输入: [2,3,1,1,4]\
输出: true\
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
### 关键词
贪心算法
### 难点
数组中每个元素，从左边到右边移动，每个元素只会访问一次，而且不会逆顺序访问，只考虑跳跃的范围而不考虑跳跃的步数，这就是非重复的子问题。\
但是如果考虑每一步跳跃多少距离，就会可能有重复或者后退的情况，这就是动态规划。
### 代码
~~~c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if (nums.size() == 1) return true; // 只有一个元素，就是能达到
        for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
        }
        return false;
    }
};
~~~
### 总结
局部最优解为当前位置能到达的最大范围，全局最优解为移动的步数产生的全局最优解，这里的对数组中的n个元素进行遍历的操作不是在一步一步跳跃，而是在n个元素中找出可能的情况，只有当cover = i + num[i]时才说明跳跃开始。
## 45.跳跃游戏 II
给定一个非负整数数组，你最初位于数组的第一个位置。\
数组中的每个元素代表你在该位置可以跳跃的最大长度。\
你的目标是使用最少的跳跃次数到达数组的最后一个位置。\
示例:
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳  1  步，然后跳  3  步到达数组的最后一个位置。
### 关键词
贪心算法
### 难点
和跳跃游戏I一样，每次都要选择跳跃所能到达的最大距离后再移动。这可以通过判断当前访问的下标是否到达了当前的最大范围决定，也就是说需要一个变量来计算当前的最大范围，就和跳跃游戏I中的cover一样。\
若当前的元素下标达到最大范围时，要准备进行跳跃，因此跳跃步数要加一，同时还需要更新当前的最大范围，如何更新最大范围呢？\
在元素在一个范围内移动时，由于贪心算法的特性，元素总是想要进行最大范围的跳跃。在这个范围内，可以通过max(num[i] + i, next_cover)拿到元素在这个区间内下一步能够到达的最大区间，在这个范围里，不考虑元素如何移动，只考虑元素下一步跳跃可能的最大范围，如此就杜绝了前进一步还是两步的思考。这个范围是由当前的最大范围决定的。\
当前的最大范围初始值为0，因为当元素在0的位置时，不管怎样，只要不是数组大小为1的情况下，都是要进行跳跃的。\
之所以需要对数组进行步长为1的遍历，可以这么理解：我们需要遍历数组中的每一个元素来计算能够跳跃的最大距离，而不是想当然地从某一步开始计算下一步的最大距离，因为我们不知道具体是怎么跳的，只知道范围。
### 代码
~~~C++
class Solution {
public:
    int jump(vector<int>& nums) {
        int count = 0;
        int cur_cover = 0;
        int next_cover = 0;
        for(int i = 0; i < nums.size(); i++) {
            next_cover = max(i + nums[i], next_cover);
            if (i == cur_cover) {
                if (i >= nums.size() - 1) {
                    break;
                }
                count++;
                cur_cover = next_cover;
            }
        }
        return count;
    }
};
~~~
### 总结
基于贪心思想，每一步的跳跃要求到达最大距离后才进行跳跃，因此需要一个cur_cover记录当前能够移动的最大距离，在能够移动的范围中，又不断计算下一步的最大距离，直到当前距离大于或等于最后一个位置
## 1005.K次取反后最大化的数组和
给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）\
以这种方式修改数组后，返回数组可能的最大和。\
示例 1：
输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1) ，然后 A 变为 [4,-2,3]。
### 难点
如何理解本题的贪心，本题一步一步相加，并不会导致元素重复相加的情况，因此可以使用贪心算法解决。\
贪心的每一步是要找到局部最优解，为了使得相加的和最大，要求负数转化为1，负数不够转化的情况下，转化最小的整数。\
如果负数全部转化后还有剩余，那就必须要优先转化绝对值大的负数，使得总和较大。
### 代码
~~~c++
class Solution {
static bool cmp(int a, int b) {
    return abs(a) > abs(b);
}
public:
    int largestSumAfterKNegations(vector<int>& A, int K) {
        sort(A.begin(), A.end(), cmp);       // 第一步，根据绝对值大小，由大到小
        for (int i = 0; i < A.size(); i++) { // 第二步，遍历所有负数
            if (A[i] < 0 && K > 0) {
                A[i] *= -1;
                K--;
            }
        }
        if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步，有多余的k，只需要处理最小的数
        int result = 0;
        for (int a : A) result += a;        // 第四步，计算总和
        return result;
    }
};
~~~
### 难点
本体不难理解，但是难的是解题的代码书写。需要优先将负数挑出来，面对k较大的情况，还需要找到绝对值最小的数进行反复替换。因此最优的排序就是根据绝对值大小排序
