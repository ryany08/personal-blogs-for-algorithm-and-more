---
Title: GreedyAlgorithm02
Date: 2025-6-3
---
# 算法训练营 | 122.买卖股票的最佳时机 II | 55. 跳跃游戏
## 122.买卖股票的最佳时机 II
给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。\
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）\
示例 1:\
输入: [7,1,5,3,6,4]\
输出: 7\
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
### 关键词
贪心算法
### 难点
本题的列表是有着自己固定的顺序的，因此不能采用一般的排序方法解决解决贪心问题的思路。\
本题最重要的信息就是买入和卖出，实际上这几天的交易所获得的利润可以分割成多此交易获得的利润总和。这就能分割成子问题。\
同时，只持有一支股票，也就是同时只能做一次交易，杜绝了子问题重叠的情况（多只股票同时交易），而解决无重复子问题的方法就是贪心算法。\
数组中相邻两个元素，后一个元素减去前一个元素就是这两天交易获取到的利润。同理同一天买卖获得的利润为0（同一个价格买入卖出）。\
思路就有了，通过计算相邻两个数的差，得到这两天求得的利润，若为正，说明第一天买，第二天买是有利可得的，为了赚取更多的钱，虽然有利可得但是仍不卖出，等待下一个交易日。\
接着在移动到下一个二元组，也就是下一个交易日，如果仍是正数则说明仍有利可得，下一个交易日再卖出能赚更多钱；如果为负数，则说明在这个交易日会亏钱，立马在上一个交易日卖出，开启新一轮的买卖。\
### 代码
~~~C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
~~~
### 总结
贪心算法的核心就是非重叠的子问题
## 55. 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。\
数组中的每个元素代表你在该位置可以跳跃的最大长度。\
判断你是否能够到达最后一个位置。\
输入: [2,3,1,1,4]\
输出: true\
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
### 关键词
贪心算法
### 难点
数组中每个元素，从左边到右边移动，每个元素只会访问一次，而且不会逆顺序访问，只考虑跳跃的范围而不考虑跳跃的步数，这就是非重复的子问题。\
但是如果考虑每一步跳跃多少距离，就会可能有重复或者后退的情况，这就是动态规划。
### 代码
~~~c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if (nums.size() == 1) return true; // 只有一个元素，就是能达到
        for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
        }
        return false;
    }
};
~~~
### 总结
局部最优解为当前位置能到达的最大范围，全局最优解为移动的步数产生的全局最优解
