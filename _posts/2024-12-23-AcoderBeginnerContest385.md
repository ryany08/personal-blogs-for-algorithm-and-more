---
Title: AcoderBeginnerContest385
Date: 2024-12-23
---
# Atcoder Beginner Contest 385
## C 
给出一个整型数组H，长度为L，求这个数组中，间隔相同的数值相同的元素的最多个数。
##  思路
最开始想到的思路是动态规划，但是局限于局限于一维的动态规划了，单纯只想到了用一维数组表示到该位置时最多的元素个数。一维DP数组下，无法由前面的状态推出后面的状态，**因为不知道跨越的元素个数，更新状态后还需要记录是从哪里转过来的，跨越的距离为多少**\
如果使用另一个维度记录跨越的的距离，组成二维dp数组，就能比价好地解决这个问题。\
dp[i+j][j] = { dp[i][j] +1(if H[i+j] = H[i]) 1(otherwise) }
## 代码

# D
记录圣诞老人经历过的家和最终的低点，给出圣诞老人起始方位x, y。所有家的位置(x1,y1),...,(xn, yn);和一个行动顺序，包含方向和行进步数
## 思路
如何记录家的位置和如何在遍历过家之后，如何将其移除。这两点是比较困难的。由于圣诞老人只在上下左右四个方向移动，因此每次移动只会在x或y的任意一个坐标上移动。如果通过x和y记录所有家的位置，就能够比较好的访问并记录经过了那几所家。\
因此需要用两个map记录固定x和固定y下的家的位置，便利寻找。\
那么，如何记录固定一个坐标轴下的所有家的位置呢。我们可以选vector，set，unordered_set等容器。如果选择vector和unordered_map，这两个容器都不会为元素进行排序，因此就会需要花N ** 2的时间去找到所有涵盖在本次移动范围内的所有城市。而如果使用
set，则会自动为容器内的元素排序，而set的查找时间为对数，最终需要logN的时间找出一个元素，而由于set按照大小排序，故寻找所有家的所耗时间为logN。一旦找出之后，就使用erase将所有找到的家删除。

## E
构建雪花树，一颗雪花树由节点和一层节点和二层节点组成。一层节点个数为x，二层节点个数为x * y。求对所给的节点减去最少的节点数得到的雪花树。
##  思路
给定节点个数N，组成的雪花树个数为1 + x + x * y。其实就是求相差的个数N - （1 + x + x * y ）。遍历所有节点，求出该差值的最小值，就是所谓的结果

