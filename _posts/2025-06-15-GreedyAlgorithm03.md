---
Title: GreedyAlgorithm03
Date: 2025-06-15
---
# 134. 加油站 | 135. 分发糖果
## 134. 加油站
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。\
说明:\
如果题目有解，该答案即为唯一答案。\
输入数组均为非空数组，且长度相同。\
输入数组中的元素均为非负数。\
示例 1: 输入:\
gas = [1,2,3,4,5]\
cost = [3,4,5,1,2]\
输出: 3 解释:\
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\
因此，3 可为起始索引。\
### 难点
初看这道题采用贪心法完全没有头绪，不能排序（一是值与顺序有关而且要求需要环行一周，固定顺序，二是找不到应该排序的标杆）。\
但是暴力法很好做，只需要从n个位置开始遍历数组，就能找到可以环行一周的情况。\
贪心算法的解法：留意gas和cost的差值，这就是从一个加油站到另一个加油站的汽油损耗，如果一段距离的差值的和小于0，说明不可能从这个区域内开始。要注意，这样的方法说明最后一个值只会是负数，而不可能是正数。\
如果为正数，那么就直接会从这个数开始计算了。
### 代码
~~~C++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
};
~~~
### 总结
这道题的贪心算法比较巧妙，看似需要考虑顺序，实则由于必定围绕一圈，因此可以通过两数组的差值判断是否存在解。对于存在解的情况，由于固定要计算围绕一圈的损耗，从任何位置开始其实都差不多，只需要计算可能的，差值不为负数的情况。
## 135. 分发糖果
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\
你需要按照以下要求，帮助老师给这些孩子分发糖果：\
每个孩子至少分配到 1 个糖果。\
相邻的孩子中，评分高的孩子必须获得更多的糖果。\
那么这样下来，老师至少需要准备多少颗糖果呢？\
示例 1:\
输入: [1,0,2]\
输出: 5\
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。\
### 难点
观察所给数组，发现不能使用排序法，因为结果与所给顺序密切相关。\
这道题以一般的思路来看，需要同时考虑两边，但是如果同时考虑两边，就会出现顾此失彼的情况，因为每一个元素都要考虑两边，而其两边的元素就同时要考虑其自身的两边，这就导致局部问题变成了全局问题，牵一发而动全身\
而贪心算法解决的是局部非重叠子问题，这些问题可以认为是独立的，可以分开解决再合并起来的。\
因为同时考虑两边不属于非重叠子问题，尝试单考虑一边。\
注意到这个数组中，单边相邻元素必定会导致值的增加。
### 代码
~~~C++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        // 从后向前
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] ) {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        // 统计结果
        int result = 0;
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
        return result;
    }
};
~~~
### 总结
本题确实困难，最主要是要想到分两次，每次只考虑一边的情况。因此在遇到需要考虑两个维度的情况下，需要**一个维度一个维度地来**
## 860.柠檬水找零
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。\
顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\
每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\
注意，一开始你手头没有任何零钱。\
如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\
示例 1：\
输入：[5,5,5,10,20]\
输出：true\
解释：\
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\
由于所有客户都得到了正确的找零，所以我们输出 true。\
### 难点
本题需要考虑钞票的种类与实际找钱方式的对应关系。记录三种钞票的数量，5美元无需找零，而10美元找零一张5元，20美元则有两种诏找零方法：10美元和5美元各一张；5美元3张。\
每有一位顾客到来，就根据所给美元与找零的方式判断是否满足情况。
### 代码
~~~C++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0, twenty = 0;
        for (int bill : bills) {
            // 情况一
            if (bill == 5) five++;
            // 情况二
            if (bill == 10) {
                if (five <= 0) return false;
                ten++;
                five--;
            }
            // 情况三
            if (bill == 20) {
                // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                    twenty++; // 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零
                } else if (five >= 3) {
                    five -= 3;
                    twenty++; // 同理，这行代码也可以删了
                } else return false;
            }
        }
        return true;
    }
};
~~~~
### 总结
只要想到根据支付的钞票种类有不同的找零方式就能解出这道题
## 406.根据身高重建队列
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\
请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\
示例 1：\
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\
解释：\
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
### 难点
这道题一看有两个维度：一是身高，二是位次要求。就想到是否需要先考虑其中一个维度，再考虑另一个维度。而难点就在于：到底应该考虑哪个维度。\
分发糖果问题中，无论是先考虑左边还是先考虑右边，都没有关系。而这道题就有关系了。\
如果以第二个维度，也就是位次要求作为考虑的因素，排序后可以发现，两个维度的要求都没有得到满足。这是因为第二个维度实际上是基于第一个维度的，也就是说第一个维度，即身高是根据身高进行排序的基础。\
因此**需要以第一个维度，也就是身高进行排序**\
以身高从高到低的顺序排序，再以第二个维度对元素进行插入。因为身高是由高到低排序，后面的元素在插入相应的位置时，一定能够保证前面的元素的身高是比它高的。因此两个维度都得到满足。
### 代码
~~~C++
// 版本二
class Solution {
public:
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插入到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();
            while (position--) { // 寻找在插入位置
                it++;
            }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};
~~~
### 总结
遇到同时贪心两个维度的题目，一定那个要先贪心其中的一个部分，之后才是另一个部分。**而先贪心哪一个部分也是有讲究的，一定是贪心最底层的部分**，如本题中，第二个部分要求前面有n个更高的元素，这第二个部分就是基于身高这第一个部分得出的。


